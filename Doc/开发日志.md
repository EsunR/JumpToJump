# MVC模式的实现

![MVC.jpg](http://img.cdn.esunr.xyz/MVC.png)

# Camera

相机位置：

![20190823145143.png](http://img.cdn.esunr.xyz/markdown/20190823145143.png)

# Scene

> src/scene/scene.js

Scene 是场景管理器，采用单例模式，因为游戏中只存在一个 Scene，导出的即为一个实例化后的场景，其 `THREE.Scene` 实例挂载在 `instance` 对象上。

在 `init()` 函数中进行场景的初始化，主要负责实例化 `THREE.Scene`，将相机、光线这些全局的元素引入到场景中，并进行初始化等操作。

在系统定义的 Scene 中，主要是用于管理整个场景的变化。同时涉及光线与相机的操作（如相机的位移），必须作为 Scene 的方法，在外部调用 Scene 实例的方法，从而进行操作与更改，这样做的好处是能够将操作更加集中，并且减少重复的函数编写。

> 由于分数是在相机坐标系上添加的，所以也必须在 Scene 上定义分数更新、添加的操作（因为这些操作设计操作到相机实例）

若是在场景中添加物体，则可以使用 `scene.instance.add()` 方法将物体直接添加到场景中，如果在，这也是场景管理器的重要作用之一。

# 计分系统

计分系统需要使用到字体文件，字体文件存放在 `src/view3d/font.js` 文件下。

在 `font.js` 中，使用 `import` 引入一个单独的 THREE JS 可以防止缺少依赖。font 字体为 json 格式，将其存放在 `font` 变量中后，使用 `new THREE.Font(font)` 实例化一个字体对象 `fontObj`。将字体对象导出后，就可以提供给外部使用。

```js
import * as THREE from '../../libs/three.js'
const font = {...}
const fontObj = new THREE.Font(font)
export default fontObj
```

拥有字体文件后，需要有字体实例可以添加到游戏中，这里使用工厂模式，向外提供一个字体对象，将 THREE JS 字体对象绑定在 `instance` 属性上：

```js
init(options) {
  this.material = new THREE.MeshBasicMaterial({
    color: (options && options.fillStyle) ? options.fillStyle : 0xffffff,
    transparent: true
  })
  if (options && options.opacity) {
    this.material.opacity = options.opacity
  }
  this.options = options || {}
  const geometry = new THREE.TextGeometry('0', {
    "font": font,
    "size": 6.0,
    "height": 0.1
  })
  this.instance = new THREE.Mesh(geometry, this.material)
  this.instance.name = 'scoreText'
}
```

由于文字随着分数的增加而不断增加，所以在 ScoreText 上要挂载一个 updateScore 的方法来替换 instance 实例，生成一个新的文字，之后再通过场景管理器，将原有的文字删除，重新添加上新的文字实例。其内部过程如下：

![20190902200721.png](http://img.cdn.esunr.xyz/markdown/20190902200721.png)


# 暂停动画的逻辑

在动画函数库中设置两个标识符，`animationId` 与 `stoppedAnimationId`。

- `animationId`：用于记录动画ID，每次动画赋予ID都是在这个值上累加
- `stopAnimationId`：标记被暂停的动画

当一个动画被创建后（`TweenAnimation` 函数中），会被赋予一个动画ID：

```js
// animation.js
const selfAnimationId = ++animationId
```

同时设定一个判断条件，如果当前的动画 ID 小于 `stoppedAnimationId`，就跳过动画的执行：

```js
// animation.js
if (start <= frameCount && selfAnimationId > stoppedAnimationId) {
  options.callback(value)
  requestAnimationFrame(step)
} else if (start > frameCount && selfAnimationId > stoppedAnimationId) {
  // 参数true用于检测该回调是否是完成时的回调函数
  options.callback(to, true)
}
```

这个停止动画的操控在 `StopAllAnimation()` 方法中执行：

```js
// animation.js
export function StopAllAnimation() {
  stoppedAnimationId = animationId
}
```

外部调用这个方法可以停止当前场景中的所有动画

# 粒子系统 Particles

瓶身跳跃时会出现粒子聚合效果，当瓶身落下时会出现粒子发散效果。

如果要想创建一个粒子效果，则需创建单个粒子个体，将粒子作为瓶身的一部分，添加到瓶身的 Object3D 对象上，构建单个粒子个体的过程在 `bottle.js` 的 `init()` 方法中。

其中粒子贴图分为两种：绿色粒子与白色粒子，其中负责聚合效果的粒子有20个，负责散发效果的粒子有10个。这些粒子在未使用状态下时是不可见的，同时每个粒子贴图都附着在一个独立存在的宽高为2的 PlaneGeometry 对象上，所以实际上粒子只是一个朝向相机的平面贴图。

同时，每个粒子实体上挂载了两个属性：`gathering` 与 `scattering`，分别用来设置当前粒子的状态是正在执行聚合动画还是正在执行发散动画。

## 粒子聚合 Gather

![20190905110518.png](http://img.cdn.esunr.xyz/markdown/20190905110518.png)

`bottle.js` 中的 `gatherParticles()` 方法负责控制粒子的聚合效果，其内部调用 `_gatherParticles(particle)` 负责每个粒子的具体动画效果的展现。

`gatherParticles()` 将每个粒子的 `gathering` 属性设置为 `true`，意味着当前粒子正在执行聚合动画，之后将执行聚合动画的单个粒子实例传入到 `_gatherParticles(particle)`，在这里通过定时器将动画设置为分为两批执行。

`_gatherParticles(particle)` 控制单个粒子实例，将单个粒子位置与大小在一定范围内的随机初始化，其中粒子出现的距离范围为`(1, 8)`，缩放的大小范围为`(1, 1.8)`，且只随机出现在瓶身底部平面之上的四个象限内。设置了初始位置之后，开始在随机一段时间后执行聚合动画，当粒子的聚合动画执行完毕后，会检测当前瓶身的状态，如果 `bottle.gathering === true`，则表明粒子聚合动画仍在执行，则重新调用 `_gatherParticles(particle)`，直到 `bottle.gathering !== true`，停止粒子的运动。

为了停止粒子的运动，使用 `resetGatherParticles()` 方法，将粒子队列中所有的粒子 `gathering` 属性设置为 `false`。

当用户按压屏幕，在瓶身进行 `shrink` 的过程时执行 `gatherParticles()` 开始聚合粒子。当用户手指离开屏幕，在瓶身进行 `flying` 的过程时执行 `resetGatherParticles()` 停止聚合粒子。

## 粒子发散 Scatter

![20190905110609.png](http://img.cdn.esunr.xyz/markdown/20190905110609.png)

与粒子聚合相似，在 `bottle.js` 中 `scatterParticles()` 负责设置粒子的聚合状态，在这里只使用10个白色粒子完成发散动画即可。
 
`_scatterParticle(particle)` 负责单个粒子实体进行发散动画，在初始化过程中，其距离的设置与聚合粒子不一样，由于其贴近瓶身发散，所以粒子距瓶身的距离更近，距离范围为 `(1, 2)`。同时其动画执行的时间更短，运动的距离更远。

由于粒子发散的动画是单次的，所有粒子在动画执行完毕后即可将自身的 `scattering` 与 `visiable` 属性设置为 `false`，无需要重复调用自身动画。




