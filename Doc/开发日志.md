# MVC模式的实现

![MVC.jpg](http://img.cdn.esunr.xyz/MVC.png)

# Camera

相机位置：

![20190823145143.png](http://img.cdn.esunr.xyz/markdown/20190823145143.png)

# Scene

> src/scene/scene.js

Scene 是场景管理器，采用单例模式，因为游戏中只存在一个 Scene，导出的即为一个实例化后的场景，其 `THREE.Scene` 实例挂载在 `instance` 对象上。

在 `init()` 函数中进行场景的初始化，主要负责实例化 `THREE.Scene`，将相机、光线这些全局的元素引入到场景中，并进行初始化等操作。

在系统定义的 Scene 中，主要是用于管理整个场景的变化。同时涉及光线与相机的操作（如相机的位移），必须作为 Scene 的方法，在外部调用 Scene 实例的方法，从而进行操作与更改，这样做的好处是能够将操作更加集中，并且减少重复的函数编写。

> 由于分数是在相机坐标系上添加的，所以也必须在 Scene 上定义分数更新、添加的操作（因为这些操作设计操作到相机实例）

若是在场景中添加物体，则可以使用 `scene.instance.add()` 方法将物体直接添加到场景中，如果在，这也是场景管理器的重要作用之一。

# 计分系统

计分系统需要使用到字体文件，字体文件存放在 `src/view3d/font.js` 文件下。

在 `font.js` 中，使用 `import` 引入一个单独的 THREE JS 可以防止缺少依赖。font 字体为 json 格式，将其存放在 `font` 变量中后，使用 `new THREE.Font(font)` 实例化一个字体对象 `fontObj`。将字体对象导出后，就可以提供给外部使用。

```js
import * as THREE from '../../libs/three.js'
const font = {...}
const fontObj = new THREE.Font(font)
export default fontObj
```

拥有字体文件后，需要有字体实例可以添加到游戏中，这里使用工厂模式，向外提供一个字体对象，将 THREE JS 字体对象绑定在 `instance` 属性上：

```js
init(options) {
  this.material = new THREE.MeshBasicMaterial({
    color: (options && options.fillStyle) ? options.fillStyle : 0xffffff,
    transparent: true
  })
  if (options && options.opacity) {
    this.material.opacity = options.opacity
  }
  this.options = options || {}
  const geometry = new THREE.TextGeometry('0', {
    "font": font,
    "size": 6.0,
    "height": 0.1
  })
  this.instance = new THREE.Mesh(geometry, this.material)
  this.instance.name = 'scoreText'
}
```

由于文字随着分数的增加而不断增加，所以在 ScoreText 上要挂载一个 updateScore 的方法来替换 instance 实例，生成一个新的文字，之后再通过场景管理器，将原有的文字删除，重新添加上新的文字实例。其内部过程如下：

![20190902200721.png](http://img.cdn.esunr.xyz/markdown/20190902200721.png)




